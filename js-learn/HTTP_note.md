HTTP遵循经典的client-server 模型，HTTP是无状态协议
在请求与响应之间，还有许多的被称为proxy的实体，他们的作用与表现各不相同，比如网关、代理或caches等

## 目录
- [缓存](HTTP_note.md#缓存)
- [Cookie](HTTP_note.md#Cookie)
- [访问控制（CORS）](HTTP_note.md#CORS)







### 缓存
缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。

缓存包含浏览器缓存、代理缓存、网关缓存、CDN、反向代理缓存和负载均衡器等

一般只有GET请求才会被缓存

#### 缓存控制 **Cache-control** 头

请求头和响应头都支持这个属性
- `Cache-Control: max-age=31536000` 过期机制/ 单位：秒
- `Cache-Control: private  / public` 私有缓存和公共缓存
- `Cache-Control: no-cache, no-store` 禁止进行缓存
- `Cache-Control: must-revalidate` 强制确认缓存

#### 缓存处理过程

**Expires** 存储的是一个用来控制缓存失效的日期，*Expires* 头使用的是一个特定的时间，要求客户端和服务器端的时钟严格同步。客户端的时间是可以修改的，如果服务器和客户端的时间不统一，这就导致有可能出现缓存提前失效的情况，存在不稳定性。 面对这种情况，HTTP1.1引入了 **Cache-Control** 头来克服 *Expires* 头的限制。*Cache-Control* 使用max-age制定资源被缓存多久。

当设置了 `Cache-Control: max-age=N` 令缓存寿命为 `N`，客户端发起一个请求时，缓存检索到已有一个对应的缓存副本，当请求时间在寿命`N`内，直接返回缓存副本；当请求时间超过了寿命，缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否依然还是新鲜的（有效的），若服务器返回了 **304** (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样节省了带宽。若服务器通过 If-None-Match 或 If-Modified-Since 判断后发现已过期，那么会带有该资源的实体内容返回。

如果 *max-age* 和 *Expires* 同时出现，则 *max-age* 有更高的优先级，浏览器会根据 *max-age* 的时间来确认缓存过期时间。 如果 *max-age* 和 *expires* 属性都没有，找找头里的 *Last-Modified* 信息。如果有，缓存的寿命就等于头里面Date的值减去 **Last-Modified** 的值除以10。

如果缓存的响应头信息里含有 `Cache-control: must-revalidate` 或 用户点击刷新按钮时，会触发缓存校验

作为缓存的一种强校验器，**ETag** 响应头是文件修改时间、文件大小和inode号生成的校验（checksum）值。如果资源请求的响应头里含有 *ETag*, 客户端可以在后续的请求的头中带上 **If-None-Match** 头来验证缓存

作为缓存的一种弱校验器，**Last-Modified** 响应头只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 **If-Modified-Since** 来验证缓存。

**Vary** 是一个HTTP响应头部信息，决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。
对于服务器提供的某个接口来说，有时候会出现不同客户端应该获取不同资源，比如要区分移动端和桌面端的展示内容（css、图片）、客户端支持的压缩编码方式不同、在IE6浏览器上要输出不一样的内容。所以，服务器提供的同一个接口，客户端进行同样的网络请求，对于不同种类的客户端可能需要的数据不同，服务器端的返回方式返回数据也会不同。对于这个问题的解决，我想很多人是清除的，我们可以在请求信息添加Accept-Encoding、User-Agent等头部，Vary头的内容如果是多条则用 “`,`” 分割。
- **Accept-Encoding** 表示客户端支持的编码格式，常见的编码格式有gzip/compress/deflate/identity，服务器端会根据客户端提供的Accept-Encoding对返回的内容进行编码，并通过添加响应头Content-Encoding表明服务器端使用的编码格式。
- **User-Agent** 表示客户端代理，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。这样服务器就能区别不同种类的客户端，做出不同的数据返回操作。


#### 加速资源/发布

为了优化缓存，过期时间应设置得尽量长。但对于那些长期不更新的资源，特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。这时出了一种 **静态资源版本更新与缓存** ，不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号（hash或时间戳 变化的字符串）。加上版本号后的资源就被视作一个完全新的独立的资源。

```` html
<link rel="stylesheet" type="text/css" href="a.css?v1"/>
<script type="text/javascript" src="b.js?t=201804231123"></script>
````

但是这么做也存在一个问题，所有引用这个资源的地方都需要更新链接，当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。

这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于网站发布互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。



